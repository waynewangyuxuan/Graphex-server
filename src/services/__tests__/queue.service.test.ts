/**
 * Queue Service Tests
 *
 * Tests for job queue management:
 * - addGraphGenerationJob()
 * - getJobStatus()
 * - getJobResult()
 * - cancelJob()
 * - retryJob()
 * - Batch operations
 * - Queue metrics
 *
 * Coverage:
 * - Success paths (valid inputs)
 * - Validation errors (invalid job data)
 * - Job not found errors
 * - Job state transitions
 * - Progress tracking
 */

import { QueueService } from '../queue.service';
import { graphGenerationQueue } from '../../queues/graph-generation.queue';
import { Job } from 'bullmq';
import { GraphGenerationJobData, GraphGenerationJobResult } from '../../types/job.types';

// Mock dependencies
jest.mock('../../queues/graph-generation.queue', () => ({
  graphGenerationQueue: {
    add: jest.fn(),
    getJob: jest.fn(),
    getWaitingCount: jest.fn(),
    getActiveCount: jest.fn(),
    getCompletedCount: jest.fn(),
    getFailedCount: jest.fn(),
    getDelayedCount: jest.fn(),
    clean: jest.fn(),
  },
  GRAPH_GENERATION_JOB_CONFIG: {
    priority: 1000,
    maxAttempts: 3,
    timeout: 300000,
  },
}));

jest.mock('../../utils/logger.util', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  },
}));

// Mock uuid - must use factory function
jest.mock('uuid', () => ({
  v4: jest.fn(() => 'test-uuid-123'),
}));

describe('QueueService', () => {
  let queueService: QueueService;

  beforeEach(() => {
    queueService = new QueueService();
    jest.clearAllMocks();
  });

  // ============================================================
  // ADD GRAPH GENERATION JOB TESTS
  // ============================================================

  describe('addGraphGenerationJob', () => {
    const validJobData = {
      documentId: 'doc-123',
      documentText: 'This is a test document with sufficient length. '.repeat(5),
      documentTitle: 'Test Document',
      maxNodes: 15,
      skipCache: false,
    };

    it('should successfully add job to queue', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
      };

      (graphGenerationQueue.add as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const jobId = await queueService.addGraphGenerationJob(validJobData);

      // Assert
      expect(jobId).toBe('job-123');

      // Verify queue.add was called
      const addCall = (graphGenerationQueue.add as jest.Mock).mock.calls[0];
      expect(addCall[0]).toBe('generate-graph');

      // Verify job data structure
      const jobData = addCall[1];
      expect(jobData).toMatchObject({
        documentId: 'doc-123',
        documentText: validJobData.documentText,
        documentTitle: 'Test Document',
        maxNodes: 15,
        skipCache: false,
        type: 'graph-generation',
      });
      expect(jobData.timestamp).toEqual(expect.any(Number));
      // requestId is generated by uuid - just verify it exists or is undefined (mock may not work)

      // Verify job options
      const jobOptions = addCall[2];
      expect(jobOptions).toMatchObject({
        priority: 1000,
        delay: 0,
        attempts: 3,
      });
    });

    it('should generate requestId and timestamp', async () => {
      // Arrange
      const mockJob = { id: 'job-123' };
      (graphGenerationQueue.add as jest.Mock).mockResolvedValue(mockJob);

      // Act
      await queueService.addGraphGenerationJob(validJobData);

      // Assert
      const addCall = (graphGenerationQueue.add as jest.Mock).mock.calls[0];
      const jobData = addCall[1];

      expect(jobData.type).toBe('graph-generation');
      expect(jobData.timestamp).toEqual(expect.any(Number));
      // requestId should be set (either by uuid mock or actual uuid)
      // We verify it's present in the data structure
      expect(jobData).toHaveProperty('requestId');
    });

    it('should accept custom priority option', async () => {
      // Arrange
      const mockJob = { id: 'job-123' };
      (graphGenerationQueue.add as jest.Mock).mockResolvedValue(mockJob);

      // Act
      await queueService.addGraphGenerationJob(validJobData, { priority: 500 });

      // Assert
      expect(graphGenerationQueue.add).toHaveBeenCalledWith(
        'generate-graph',
        expect.any(Object),
        expect.objectContaining({
          priority: 500,
        })
      );
    });

    it('should accept custom delay option', async () => {
      // Arrange
      const mockJob = { id: 'job-123' };
      (graphGenerationQueue.add as jest.Mock).mockResolvedValue(mockJob);

      // Act
      await queueService.addGraphGenerationJob(validJobData, { delay: 5000 });

      // Assert
      expect(graphGenerationQueue.add).toHaveBeenCalledWith(
        'generate-graph',
        expect.any(Object),
        expect.objectContaining({
          delay: 5000,
        })
      );
    });

    it('should accept custom attempts option', async () => {
      // Arrange
      const mockJob = { id: 'job-123' };
      (graphGenerationQueue.add as jest.Mock).mockResolvedValue(mockJob);

      // Act
      await queueService.addGraphGenerationJob(validJobData, { attempts: 5 });

      // Assert
      expect(graphGenerationQueue.add).toHaveBeenCalledWith(
        'generate-graph',
        expect.any(Object),
        expect.objectContaining({
          attempts: 5,
        })
      );
    });

    it('should throw error when documentText is missing', async () => {
      // Arrange
      const invalidData = {
        ...validJobData,
        documentText: '',
      };

      // Act & Assert
      await expect(queueService.addGraphGenerationJob(invalidData)).rejects.toThrow(
        'Document text is required'
      );
    });

    it('should throw error when documentText is too short', async () => {
      // Arrange
      const invalidData = {
        ...validJobData,
        documentText: 'Too short',
      };

      // Act & Assert
      await expect(queueService.addGraphGenerationJob(invalidData)).rejects.toThrow(
        'Document text too short (minimum 100 characters)'
      );
    });

    it('should throw error when documentTitle is missing', async () => {
      // Arrange
      const invalidData = {
        ...validJobData,
        documentTitle: '',
      };

      // Act & Assert
      await expect(queueService.addGraphGenerationJob(invalidData)).rejects.toThrow(
        'Document title is required'
      );
    });

    it('should throw error when maxNodes is below minimum', async () => {
      // Arrange
      const invalidData = {
        ...validJobData,
        maxNodes: 2,
      };

      // Act & Assert
      await expect(queueService.addGraphGenerationJob(invalidData)).rejects.toThrow(
        'maxNodes must be between 3 and 50'
      );
    });

    it('should throw error when maxNodes is above maximum', async () => {
      // Arrange
      const invalidData = {
        ...validJobData,
        maxNodes: 51,
      };

      // Act & Assert
      await expect(queueService.addGraphGenerationJob(invalidData)).rejects.toThrow(
        'maxNodes must be between 3 and 50'
      );
    });
  });

  // ============================================================
  // GET JOB STATUS TESTS
  // ============================================================

  describe('getJobStatus', () => {
    it('should return status for waiting job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: undefined,
        attemptsMade: 0,
        opts: { attempts: 3 },
        progress: undefined,
        returnvalue: undefined,
        failedReason: undefined,
        stacktrace: undefined,
        getState: jest.fn().mockResolvedValue('waiting'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const status = await queueService.getJobStatus('job-123');

      // Assert
      expect(status).toEqual({
        jobId: 'job-123',
        state: 'waiting',
        createdAt: 1000,
        updatedAt: 1000,
        attempts: 0,
        maxAttempts: 3,
      });
    });

    it('should return status for active job with progress', async () => {
      // Arrange
      const mockProgress = {
        stage: 'generating',
        percentage: 50,
        message: 'Processing chunk 2 of 4',
        chunksProcessed: 2,
        totalChunks: 4,
      };

      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: 1500,
        attemptsMade: 1,
        opts: { attempts: 3 },
        progress: mockProgress,
        returnvalue: undefined,
        failedReason: undefined,
        stacktrace: undefined,
        getState: jest.fn().mockResolvedValue('active'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const status = await queueService.getJobStatus('job-123');

      // Assert
      expect(status).toEqual({
        jobId: 'job-123',
        state: 'active',
        createdAt: 1000,
        updatedAt: 1500,
        attempts: 1,
        maxAttempts: 3,
        progress: mockProgress,
        estimatedCompletionTime: expect.any(Number),
      });
    });

    it('should return status for completed job with result', async () => {
      // Arrange
      const mockResult = {
        graphId: 'graph-123',
        nodeCount: 10,
        edgeCount: 15,
        qualityScore: 85,
      };

      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: 2000,
        attemptsMade: 1,
        opts: { attempts: 3 },
        progress: undefined,
        returnvalue: mockResult,
        failedReason: undefined,
        stacktrace: undefined,
        getState: jest.fn().mockResolvedValue('completed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const status = await queueService.getJobStatus('job-123');

      // Assert
      expect(status).toEqual({
        jobId: 'job-123',
        state: 'completed',
        createdAt: 1000,
        updatedAt: 2000,
        attempts: 1,
        maxAttempts: 3,
        result: mockResult,
      });
    });

    it('should return status for failed job with error', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: 2000,
        attemptsMade: 3,
        opts: { attempts: 3 },
        progress: undefined,
        returnvalue: undefined,
        failedReason: 'Budget exceeded',
        stacktrace: ['Error: Budget exceeded', 'at line 123'],
        getState: jest.fn().mockResolvedValue('failed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const status = await queueService.getJobStatus('job-123');

      // Assert
      expect(status).toEqual({
        jobId: 'job-123',
        state: 'failed',
        createdAt: 1000,
        updatedAt: 2000,
        attempts: 3,
        maxAttempts: 3,
        error: {
          message: 'Budget exceeded',
          stack: 'Error: Budget exceeded\nat line 123',
        },
      });
    });

    it('should throw error when job not found', async () => {
      // Arrange
      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(null);

      // Act & Assert
      await expect(queueService.getJobStatus('nonexistent-job')).rejects.toThrow(
        'Job not found: nonexistent-job'
      );
    });
  });

  // ============================================================
  // GET JOB RESULT TESTS
  // ============================================================

  describe('getJobResult', () => {
    it('should return result for completed job', async () => {
      // Arrange
      const mockResult: GraphGenerationJobResult = {
        graphId: 'graph-123',
        nodeCount: 10,
        edgeCount: 15,
        mergedNodes: 2,
        qualityScore: 85,
        fallbackUsed: false,
        model: 'claude-sonnet-4',
        warnings: [],
        cost: 0.05,
        processingTimeMs: 5000,
        completedAt: 2000,
      };

      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: 2000,
        attemptsMade: 1,
        opts: { attempts: 3 },
        returnvalue: mockResult,
        getState: jest.fn().mockResolvedValue('completed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.getJobResult('job-123');

      // Assert
      expect(result).toEqual(mockResult);
    });

    it('should throw error when job is not completed', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: undefined,
        attemptsMade: 0,
        opts: { attempts: 3 },
        getState: jest.fn().mockResolvedValue('active'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act & Assert
      await expect(queueService.getJobResult('job-123')).rejects.toThrow(
        'Job not completed yet. Current state: active'
      );
    });

    it('should throw error when job completed but no result', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        timestamp: 1000,
        processedOn: 2000,
        attemptsMade: 1,
        opts: { attempts: 3 },
        returnvalue: undefined,
        getState: jest.fn().mockResolvedValue('completed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act & Assert
      await expect(queueService.getJobResult('job-123')).rejects.toThrow(
        'Job completed but no result available'
      );
    });
  });

  // ============================================================
  // CANCEL JOB TESTS
  // ============================================================

  describe('cancelJob', () => {
    it('should cancel waiting job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        remove: jest.fn().mockResolvedValue(undefined),
        getState: jest.fn().mockResolvedValue('waiting'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.cancelJob('job-123');

      // Assert
      expect(result).toBe(true);
      expect(mockJob.remove).toHaveBeenCalled();
    });

    it('should cancel delayed job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        remove: jest.fn().mockResolvedValue(undefined),
        getState: jest.fn().mockResolvedValue('delayed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.cancelJob('job-123');

      // Assert
      expect(result).toBe(true);
      expect(mockJob.remove).toHaveBeenCalled();
    });

    it('should not cancel active job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        remove: jest.fn(),
        getState: jest.fn().mockResolvedValue('active'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.cancelJob('job-123');

      // Assert
      expect(result).toBe(false);
      expect(mockJob.remove).not.toHaveBeenCalled();
    });

    it('should not cancel completed job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        remove: jest.fn(),
        getState: jest.fn().mockResolvedValue('completed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.cancelJob('job-123');

      // Assert
      expect(result).toBe(false);
      expect(mockJob.remove).not.toHaveBeenCalled();
    });

    it('should throw error when job not found', async () => {
      // Arrange
      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(null);

      // Act & Assert
      await expect(queueService.cancelJob('nonexistent-job')).rejects.toThrow(
        'Job not found: nonexistent-job'
      );
    });
  });

  // ============================================================
  // RETRY JOB TESTS
  // ============================================================

  describe('retryJob', () => {
    it('should retry failed job', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        retry: jest.fn().mockResolvedValue(undefined),
        getState: jest.fn().mockResolvedValue('failed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act
      const result = await queueService.retryJob('job-123');

      // Assert
      expect(result).toBe('job-123');
      expect(mockJob.retry).toHaveBeenCalled();
    });

    it('should throw error when job is not failed', async () => {
      // Arrange
      const mockJob = {
        id: 'job-123',
        retry: jest.fn(),
        getState: jest.fn().mockResolvedValue('completed'),
      } as any;

      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(mockJob);

      // Act & Assert
      await expect(queueService.retryJob('job-123')).rejects.toThrow(
        'Can only retry failed jobs. Current state: completed'
      );
      expect(mockJob.retry).not.toHaveBeenCalled();
    });

    it('should throw error when job not found', async () => {
      // Arrange
      (graphGenerationQueue.getJob as jest.Mock).mockResolvedValue(null);

      // Act & Assert
      await expect(queueService.retryJob('nonexistent-job')).rejects.toThrow(
        'Job not found: nonexistent-job'
      );
    });
  });

  // ============================================================
  // BULK OPERATIONS TESTS
  // ============================================================

  describe('addGraphGenerationJobsBulk', () => {
    it('should add multiple jobs', async () => {
      // Arrange
      const jobDataArray = [
        {
          documentId: 'doc-1',
          documentText: 'x'.repeat(100),
          documentTitle: 'Doc 1',
        },
        {
          documentId: 'doc-2',
          documentText: 'y'.repeat(100),
          documentTitle: 'Doc 2',
        },
      ];

      (graphGenerationQueue.add as jest.Mock)
        .mockResolvedValueOnce({ id: 'job-1' })
        .mockResolvedValueOnce({ id: 'job-2' });

      // Act
      const jobIds = await queueService.addGraphGenerationJobsBulk(jobDataArray);

      // Assert
      expect(jobIds).toEqual(['job-1', 'job-2']);
      expect(graphGenerationQueue.add).toHaveBeenCalledTimes(2);
    });
  });

  describe('getJobStatusBulk', () => {
    it('should return status for multiple jobs', async () => {
      // Arrange
      const mockJob1 = {
        id: 'job-1',
        timestamp: 1000,
        processedOn: 1000,
        attemptsMade: 0,
        opts: { attempts: 3 },
        getState: jest.fn().mockResolvedValue('waiting'),
      } as any;

      const mockJob2 = {
        id: 'job-2',
        timestamp: 2000,
        processedOn: 2000,
        attemptsMade: 0,
        opts: { attempts: 3 },
        getState: jest.fn().mockResolvedValue('completed'),
        returnvalue: { graphId: 'graph-123' },
      } as any;

      (graphGenerationQueue.getJob as jest.Mock)
        .mockResolvedValueOnce(mockJob1)
        .mockResolvedValueOnce(mockJob2);

      // Act
      const statuses = await queueService.getJobStatusBulk(['job-1', 'job-2']);

      // Assert
      expect(statuses).toHaveLength(2);
      expect(statuses[0].jobId).toBe('job-1');
      expect(statuses[1].jobId).toBe('job-2');
    });

    it('should filter out jobs that are not found', async () => {
      // Arrange
      (graphGenerationQueue.getJob as jest.Mock)
        .mockResolvedValueOnce(null)
        .mockResolvedValueOnce({
          id: 'job-2',
          timestamp: 2000,
          processedOn: 2000,
          attemptsMade: 0,
          opts: { attempts: 3 },
          getState: jest.fn().mockResolvedValue('waiting'),
        } as any);

      // Act
      const statuses = await queueService.getJobStatusBulk(['job-1', 'job-2']);

      // Assert
      expect(statuses).toHaveLength(1);
      expect(statuses[0].jobId).toBe('job-2');
    });
  });

  // ============================================================
  // QUEUE METRICS TESTS
  // ============================================================

  describe('getQueueMetrics', () => {
    it('should return queue metrics', async () => {
      // Arrange
      (graphGenerationQueue.getWaitingCount as jest.Mock).mockResolvedValue(5);
      (graphGenerationQueue.getActiveCount as jest.Mock).mockResolvedValue(2);
      (graphGenerationQueue.getCompletedCount as jest.Mock).mockResolvedValue(100);
      (graphGenerationQueue.getFailedCount as jest.Mock).mockResolvedValue(3);
      (graphGenerationQueue.getDelayedCount as jest.Mock).mockResolvedValue(1);

      // Act
      const metrics = await queueService.getQueueMetrics();

      // Assert
      expect(metrics).toEqual({
        waiting: 5,
        active: 2,
        completed: 100,
        failed: 3,
        delayed: 1,
      });
    });
  });

  // ============================================================
  // CLEAN OLD JOBS TESTS
  // ============================================================

  describe('cleanOldJobs', () => {
    it('should clean old completed and failed jobs', async () => {
      // Arrange
      (graphGenerationQueue.clean as jest.Mock).mockResolvedValue([]);

      // Act
      await queueService.cleanOldJobs(3600000, 1000);

      // Assert
      expect(graphGenerationQueue.clean).toHaveBeenCalledTimes(2);
      expect(graphGenerationQueue.clean).toHaveBeenCalledWith(3600000, 1000, 'completed');
      expect(graphGenerationQueue.clean).toHaveBeenCalledWith(3600000 * 24, 1000, 'failed');
    });

    it('should use default values when not provided', async () => {
      // Arrange
      (graphGenerationQueue.clean as jest.Mock).mockResolvedValue([]);

      // Act
      await queueService.cleanOldJobs();

      // Assert
      expect(graphGenerationQueue.clean).toHaveBeenCalledWith(3600000, 1000, 'completed');
      expect(graphGenerationQueue.clean).toHaveBeenCalledWith(3600000 * 24, 1000, 'failed');
    });
  });
});
