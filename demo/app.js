// ===================================
// GRAPHEX MVP - Main Application Logic
// ===================================

// Sample Document Data
const SAMPLE_DOCUMENT = {
    title: "The Learning Pyramid: A Cognitive Science Perspective",
    content: `
        <h2>The Learning Pyramid: A Cognitive Science Perspective</h2>

        <h3 id="section-1">Introduction to Active Learning</h3>
        <p>Active learning is a process where learners engage directly with the material through activities that promote higher-order thinking. Unlike passive reading, active learning requires learners to analyze, evaluate, and create new understanding. Research consistently shows that active engagement leads to deeper comprehension and better long-term retention.</p>

        <h3 id="section-2">The Testing Effect</h3>
        <p>The testing effect, also known as retrieval practice, demonstrates that the act of recalling information strengthens memory more effectively than simply re-reading material. When we retrieve information from memory, we strengthen the neural pathways associated with that knowledge. Studies by Roediger and Karpicke (2006) showed that testing yields 60% retention after one week, compared to only 40% for re-reading.</p>

        <h3 id="section-3">Elaborative Encoding</h3>
        <p>Elaborative encoding refers to the process of connecting new information to existing knowledge structures. When learners create meaningful connections between concepts, they build richer mental representations. This process involves asking questions like "How does this relate to what I already know?" and "Why does this make sense?" The depth of processing determines how well information is retained.</p>

        <h3 id="section-4">Spaced Repetition</h3>
        <p>Spaced repetition is a learning technique that involves reviewing information at increasing intervals over time. Rather than cramming all at once, distributed practice leads to superior long-term retention. The spacing effect has been demonstrated across numerous studies, showing that optimal intervals depend on desired retention periods. For one-month retention, reviewing after one week is ideal.</p>

        <h3 id="section-5">Metacognition and Self-Regulated Learning</h3>
        <p>Metacognition refers to thinking about one's own thinking—the ability to monitor and regulate cognitive processes. Self-regulated learners set goals, monitor their comprehension, and adjust strategies accordingly. They recognize when they don't understand something and take corrective action. This metacognitive awareness is what separates expert learners from novices.</p>

        <h3 id="section-6">The Generation Effect</h3>
        <p>The generation effect shows that information is better remembered when it is generated by the learner rather than simply read. When learners create their own examples, explanations, or summaries, they process information more deeply. This effect is particularly strong when learners must put concepts into their own words, forcing them to construct meaning actively rather than passively absorbing pre-formed explanations.</p>

        <h3 id="section-7">Dual Coding Theory</h3>
        <p>Dual coding theory proposes that information is better retained when it is encoded both verbally and visually. The brain processes verbal and visual information through different channels, and combining both leads to stronger memory traces. Knowledge graphs exemplify dual coding by representing concepts both as text (verbal) and as spatial relationships (visual), engaging both processing systems simultaneously.</p>

        <h3 id="section-8">Conclusion: Synthesis and Application</h3>
        <p>Effective learning is not a passive process but an active construction of knowledge. By combining retrieval practice, elaborative encoding, spaced repetition, and metacognitive monitoring, learners can dramatically improve both comprehension and retention. Tools that scaffold these cognitive processes—like knowledge graph systems—can help learners engage more deeply with material while avoiding the illusion of fluency that comes from passive reading.</p>
    `,
    graph: `graph TD
    A[Active Learning] --> B[Testing Effect]
    A --> C[Elaborative Encoding]
    B --> D[Spaced Repetition]
    C --> E[Metacognition]
    A --> F[Generation Effect]
    C --> F
    A --> G[Dual Coding]
    B --> H[Synthesis]
    D --> H
    E --> H
    F --> H
    G --> H`,
    nodes: {
        'A': { id: 'section-1', title: 'Active Learning' },
        'B': { id: 'section-2', title: 'Testing Effect' },
        'C': { id: 'section-3', title: 'Elaborative Encoding' },
        'D': { id: 'section-4', title: 'Spaced Repetition' },
        'E': { id: 'section-5', title: 'Metacognition' },
        'F': { id: 'section-6', title: 'Generation Effect' },
        'G': { id: 'section-7', title: 'Dual Coding' },
        'H': { id: 'section-8', title: 'Synthesis' }
    },
    connections: {
        'A-B': {
            explanation: "Active learning is strengthened by the testing effect because retrieving information is itself an active process that requires engagement, rather than passive review.",
            sourceText: "When we retrieve information from memory, we strengthen the neural pathways associated with that knowledge."
        },
        'A-C': {
            explanation: "Elaborative encoding is a form of active learning where learners actively connect new information to existing knowledge, requiring deep engagement with the material.",
            sourceText: "Elaborative encoding refers to the process of connecting new information to existing knowledge structures."
        },
        'B-D': {
            explanation: "The testing effect is enhanced by spaced repetition because repeated retrieval over time creates stronger, more durable memory traces than single retrieval attempts.",
            sourceText: "Rather than cramming all at once, distributed practice leads to superior long-term retention."
        },
        'C-E': {
            explanation: "Elaborative encoding requires metacognition because learners must monitor their understanding and consciously decide how new information relates to existing knowledge.",
            sourceText: "They recognize when they don't understand something and take corrective action."
        },
        'A-F': {
            explanation: "The generation effect exemplifies active learning because creating your own explanations requires deeper processing than passive reception of information.",
            sourceText: "When learners create their own examples, explanations, or summaries, they process information more deeply."
        },
        'C-F': {
            explanation: "Elaborative encoding and the generation effect both involve creating connections, but generation specifically requires producing content rather than just recognizing relationships.",
            sourceText: "This effect is particularly strong when learners must put concepts into their own words, forcing them to construct meaning actively."
        },
        'A-G': {
            explanation: "Dual coding supports active learning by engaging multiple cognitive systems simultaneously, requiring learners to process information in both verbal and visual forms.",
            sourceText: "Knowledge graphs exemplify dual coding by representing concepts both as text (verbal) and as spatial relationships (visual)."
        },
        'B-H': {
            explanation: "The testing effect contributes to synthesis by forcing learners to actively retrieve and integrate multiple concepts, rather than passively reviewing isolated facts.",
            sourceText: "By combining retrieval practice, elaborative encoding, spaced repetition, and metacognitive monitoring, learners can dramatically improve both comprehension and retention."
        },
        'D-H': {
            explanation: "Spaced repetition enables synthesis by repeatedly bringing concepts back together over time, allowing learners to see new connections and deepen integration.",
            sourceText: "By combining retrieval practice, elaborative encoding, spaced repetition, and metacognitive monitoring, learners can dramatically improve both comprehension and retention."
        },
        'E-H': {
            explanation: "Metacognition enables synthesis by helping learners monitor their understanding across multiple concepts and identify gaps that need integration.",
            sourceText: "By combining retrieval practice, elaborative encoding, spaced repetition, and metacognitive monitoring, learners can dramatically improve both comprehension and retention."
        },
        'F-H': {
            explanation: "The generation effect supports synthesis because creating explanations requires integrating multiple concepts into coherent understanding.",
            sourceText: "Effective learning is not a passive process but an active construction of knowledge."
        },
        'G-H': {
            explanation: "Dual coding facilitates synthesis by providing multiple representations that can be integrated, allowing verbal and visual processing to reinforce each other.",
            sourceText: "Tools that scaffold these cognitive processes—like knowledge graph systems—can help learners engage more deeply with material."
        }
    }
};

// Quiz Questions
const QUIZ_QUESTIONS = [
    {
        question: "According to the research cited, what is the retention rate after one week for testing compared to re-reading?",
        options: [
            "Testing: 40%, Re-reading: 60%",
            "Testing: 60%, Re-reading: 40%",
            "Testing: 50%, Re-reading: 50%",
            "Testing: 80%, Re-reading: 20%"
        ],
        correct: 1,
        explanation: "The text states that testing yields 60% retention after one week, compared to only 40% for re-reading.",
        relatedNode: 'B'
    },
    {
        question: "Which concept refers to thinking about one's own thinking?",
        options: [
            "Active Learning",
            "Generation Effect",
            "Metacognition",
            "Dual Coding"
        ],
        correct: 2,
        explanation: "Metacognition refers to thinking about one's own thinking—the ability to monitor and regulate cognitive processes.",
        relatedNode: 'E'
    },
    {
        question: "What is the relationship between the Testing Effect and Spaced Repetition?",
        options: [
            "They are unrelated concepts",
            "Spaced repetition enhances the testing effect through repeated retrieval over time",
            "Testing effect replaces the need for spaced repetition",
            "They contradict each other"
        ],
        correct: 1,
        explanation: "The testing effect is enhanced by spaced repetition because repeated retrieval over time creates stronger, more durable memory traces.",
        relatedNode: 'D'
    },
    {
        question: "According to Dual Coding Theory, why are knowledge graphs effective?",
        options: [
            "They replace the need for reading",
            "They only use visual processing",
            "They engage both verbal and visual processing systems",
            "They simplify complex information"
        ],
        correct: 2,
        explanation: "Knowledge graphs exemplify dual coding by representing concepts both as text (verbal) and as spatial relationships (visual), engaging both processing systems simultaneously.",
        relatedNode: 'G'
    },
    {
        question: "What makes the Generation Effect particularly powerful?",
        options: [
            "Reading information multiple times",
            "Listening to explanations from experts",
            "Creating your own explanations and putting concepts in your own words",
            "Memorizing definitions verbatim"
        ],
        correct: 2,
        explanation: "The generation effect is particularly strong when learners must put concepts into their own words, forcing them to construct meaning actively rather than passively absorbing pre-formed explanations.",
        relatedNode: 'F'
    }
];

// ===================================
// STATE MANAGEMENT
// ===================================

const state = {
    currentDocument: null,
    notes: {},
    nodeInteractions: 0,
    quizTaken: false,
    onboardingComplete: false,
    currentConnection: null,
    quizState: {
        currentQuestion: 0,
        answers: [],
        score: 0
    }
};

// ===================================
// INITIALIZATION
// ===================================

document.addEventListener('DOMContentLoaded', () => {
    initializeEventListeners();
    mermaid.initialize({ startOnLoad: false, theme: 'base' });
});

function initializeEventListeners() {
    // File upload
    document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    document.getElementById('sampleDocBtn').addEventListener('click', loadSampleDocument);

    // Graph controls
    document.getElementById('zoomIn').addEventListener('click', () => zoomGraph(1.2));
    document.getElementById('zoomOut').addEventListener('click', () => zoomGraph(0.8));
    document.getElementById('fitScreen').addEventListener('click', fitGraphToScreen);

    // Note modal
    document.getElementById('closeNoteModal').addEventListener('click', closeNoteModal);
    document.getElementById('cancelNote').addEventListener('click', closeNoteModal);
    document.getElementById('saveNote').addEventListener('click', saveNote);
    document.getElementById('noteTextarea').addEventListener('input', updateWordCount);

    // Connection modal
    document.getElementById('closeConnectionModal').addEventListener('click', closeConnectionModal);
    document.getElementById('hypothesisTextarea').addEventListener('input', updateCharCount);
    document.getElementById('submitHypothesis').addEventListener('click', submitHypothesis);
    document.getElementById('finishConnection').addEventListener('click', closeConnectionModal);

    // Quiz
    document.getElementById('startQuiz').addEventListener('click', startQuiz);
    document.getElementById('laterQuiz').addEventListener('click', hideQuizBanner);
    document.getElementById('submitAnswer').addEventListener('click', submitQuizAnswer);
    document.getElementById('nextQuestion').addEventListener('click', nextQuizQuestion);
    document.getElementById('closeQuizModal').addEventListener('click', closeQuizModal);
    document.getElementById('returnToGraph').addEventListener('click', closeResultsModal);
    document.getElementById('closeResultsModal').addEventListener('click', closeResultsModal);

    // Close modals on overlay click
    document.querySelectorAll('.modal-overlay').forEach(overlay => {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeAllModals();
            }
        });
    });

    // ESC key to close modals
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeAllModals();
        }
    });
}

// ===================================
// DOCUMENT LOADING
// ===================================

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    showToast('info', 'File upload is simulated in this demo. Loading sample document instead.');
    setTimeout(() => loadSampleDocument(), 1000);
}

function loadSampleDocument() {
    showLoadingOverlay('Processing document...', 'Parsing document...');

    setTimeout(() => {
        updateLoadingStep('Analyzing structure...', 33);
        setTimeout(() => {
            updateLoadingStep('Generating graph...', 66);
            setTimeout(() => {
                updateLoadingStep('Finalizing...', 100);
                setTimeout(() => {
                    state.currentDocument = SAMPLE_DOCUMENT;
                    renderDocument();
                    hideLoadingOverlay();
                    showToast('success', 'Document loaded successfully!');

                    if (!state.onboardingComplete) {
                        startOnboarding();
                    }
                }, 500);
            }, 800);
        }, 800);
    }, 800);
}

function renderDocument() {
    // Hide empty state, show working area
    document.getElementById('emptyState').style.display = 'none';
    document.getElementById('workingArea').style.display = 'flex';

    // Update title
    document.getElementById('documentTitle').textContent = state.currentDocument.title;

    // Calculate and display reading time
    const wordCount = state.currentDocument.content.replace(/<[^>]*>/g, '').split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 200); // Average reading speed: 200 words/min
    const readingTimeEl = document.getElementById('readingTime');
    readingTimeEl.textContent = `~${readingTime} min read`;
    readingTimeEl.style.display = 'block';

    // Render graph
    renderGraph();

    // Render reading content
    document.getElementById('readingContent').innerHTML = state.currentDocument.content;
}

function renderGraph() {
    const graphElement = document.getElementById('mermaidGraph');
    graphElement.innerHTML = state.currentDocument.graph;

    mermaid.init(undefined, graphElement).then(() => {
        attachGraphEventListeners();
    });
}

function attachGraphEventListeners() {
    const tooltip = document.getElementById('nodeTooltip');
    let tooltipTimeout;

    // Node click and hover handlers
    document.querySelectorAll('.node').forEach((node, index) => {
        node.style.cursor = 'pointer';
        const nodeId = Object.keys(state.currentDocument.nodes)[index];
        const nodeData = state.currentDocument.nodes[nodeId];

        // Add ARIA attributes
        node.setAttribute('role', 'button');
        node.setAttribute('tabindex', '0');
        node.setAttribute('aria-label', `Concept: ${nodeData.title}. Click to read content.`);

        // Click handler
        node.addEventListener('click', () => handleNodeClick(node, index));

        // Keyboard support
        node.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleNodeClick(node, index);
            }
        });

        // Hover tooltip
        node.addEventListener('mouseenter', (e) => {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(() => {
                const rect = node.getBoundingClientRect();
                const graphPanel = document.querySelector('.graph-panel').getBoundingClientRect();
                tooltip.textContent = `Click to read • ${nodeData.title}`;
                tooltip.style.left = `${rect.left - graphPanel.left + rect.width / 2}px`;
                tooltip.style.top = `${rect.top - graphPanel.top - 35}px`;
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.classList.add('visible');
            }, 400);
        });

        node.addEventListener('mouseleave', () => {
            clearTimeout(tooltipTimeout);
            tooltip.classList.remove('visible');
        });
    });

    // Edge click handlers
    document.querySelectorAll('.edgePath').forEach(edge => {
        edge.style.cursor = 'pointer';
        edge.setAttribute('role', 'button');
        edge.setAttribute('tabindex', '0');
        edge.setAttribute('aria-label', 'Connection between concepts. Click to explore.');

        edge.addEventListener('click', (e) => {
            e.stopPropagation();
            handleEdgeClick(edge);
        });

        edge.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleEdgeClick(edge);
            }
        });
    });
}

// ===================================
// NODE INTERACTIONS
// ===================================

function handleNodeClick(node, index) {
    const nodeId = Object.keys(state.currentDocument.nodes)[index];
    const nodeData = state.currentDocument.nodes[nodeId];

    if (!nodeData) return;

    // Add pulse animation
    node.classList.add('pulse');
    setTimeout(() => node.classList.remove('pulse'), 300);

    // Remove active class from all nodes
    document.querySelectorAll('.node').forEach(n => n.classList.remove('node-active'));

    // Add active class to clicked node
    node.classList.add('node-active');

    // Scroll to section in reading panel
    scrollToSection(nodeData.id);

    // Track interaction
    state.nodeInteractions++;

    // Show quiz banner after 5 interactions
    if (state.nodeInteractions === 5 && !state.quizTaken) {
        showQuizBanner();
    }

    // Show context menu on right click
    node.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showNodeContextMenu(e, nodeId, nodeData);
    });
}

function scrollToSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (!section) return;

    const readingPanel = document.querySelector('.reading-panel');
    const sectionTop = section.offsetTop;

    readingPanel.scrollTo({
        top: sectionTop - 40,
        behavior: 'smooth'
    });

    // Highlight passage
    section.classList.add('highlighted-passage');
    setTimeout(() => {
        section.classList.remove('highlighted-passage');
    }, 3000);
}

function showNodeContextMenu(event, nodeId, nodeData) {
    // For MVP, just open note modal on regular click
    openNoteModal(nodeId, nodeData);
}

// ===================================
// EDGE/CONNECTION INTERACTIONS
// ===================================

function handleEdgeClick(edge) {
    // Get edge ID from the edge element
    const edgeLabel = edge.querySelector('.edgeLabel');
    if (!edgeLabel) return;

    // Parse connection from edge position/data
    // In a real implementation, you'd track this properly
    // For demo, we'll use a simple approach
    const connections = Object.keys(state.currentDocument.connections);
    const randomConnection = connections[Math.floor(Math.random() * connections.length)];

    openConnectionModal(randomConnection);
}

function openConnectionModal(connectionId) {
    state.currentConnection = connectionId;
    const connectionData = state.currentDocument.connections[connectionId];

    if (!connectionData) return;

    // Parse node names from connection ID
    const [fromNode, toNode] = connectionId.split('-');
    const fromName = state.currentDocument.nodes[fromNode]?.title || fromNode;
    const toName = state.currentDocument.nodes[toNode]?.title || toNode;

    document.getElementById('connectionModalTitle').textContent =
        `Connection: ${fromName} → ${toName}`;

    // Reset modal state
    document.getElementById('hypothesisStep').style.display = 'block';
    document.getElementById('explanationStep').style.display = 'none';
    document.getElementById('hypothesisTextarea').value = '';
    document.getElementById('charCount').textContent = '0';
    document.getElementById('submitHypothesis').disabled = true;

    document.getElementById('connectionModal').style.display = 'flex';
}

function updateCharCount() {
    const textarea = document.getElementById('hypothesisTextarea');
    const count = textarea.value.length;
    document.getElementById('charCount').textContent = count;

    // Enable submit button if meets minimum
    document.getElementById('submitHypothesis').disabled = count < 50;

    // Visual feedback
    const charCountEl = document.querySelector('.character-count');
    if (count >= 50) {
        charCountEl.style.color = 'var(--color-success)';
    } else {
        charCountEl.style.color = 'var(--color-text-secondary)';
    }
}

function submitHypothesis() {
    const hypothesis = document.getElementById('hypothesisTextarea').value;
    const connectionData = state.currentDocument.connections[state.currentConnection];

    // Display user's hypothesis
    document.getElementById('displayHypothesis').textContent = hypothesis;

    // Display AI explanation
    document.getElementById('aiExplanation').textContent = connectionData.explanation;

    // Display source text
    document.getElementById('sourceText').textContent = connectionData.sourceText;

    // Switch to explanation view
    document.getElementById('hypothesisStep').style.display = 'none';
    document.getElementById('explanationStep').style.display = 'block';
}

function closeConnectionModal() {
    document.getElementById('connectionModal').style.display = 'none';
    state.currentConnection = null;
}

// ===================================
// NOTE TAKING
// ===================================

let currentNoteNode = null;

function openNoteModal(nodeId, nodeData) {
    currentNoteNode = nodeId;
    document.getElementById('noteModalTitle').textContent = `Note: ${nodeData.title}`;

    // Load existing note if any
    const existingNote = state.notes[nodeId] || '';
    document.getElementById('noteTextarea').value = existingNote;
    updateWordCount();

    document.getElementById('noteModal').style.display = 'flex';
    document.getElementById('noteTextarea').focus();
}

function updateWordCount() {
    const textarea = document.getElementById('noteTextarea');
    const words = textarea.value.trim().split(/\s+/).filter(w => w.length > 0).length;
    document.getElementById('noteWordCount').textContent = `${words} words`;
}

function saveNote() {
    const note = document.getElementById('noteTextarea').value.trim();

    if (note) {
        state.notes[currentNoteNode] = note;

        // Show save status
        const saveStatus = document.getElementById('saveStatus');
        saveStatus.textContent = 'Saved ✓';
        setTimeout(() => {
            saveStatus.textContent = '';
        }, 2000);

        showToast('success', 'Note saved successfully');

        // Update node appearance (add indicator)
        updateNodeWithNote(currentNoteNode);
    }

    setTimeout(() => closeNoteModal(), 500);
}

function updateNodeWithNote(nodeId) {
    // In a real implementation, you'd update the node's visual appearance
    // For this demo, we'll just log it
    console.log(`Node ${nodeId} now has a note`);
}

function closeNoteModal() {
    document.getElementById('noteModal').style.display = 'none';
    currentNoteNode = null;
}

// ===================================
// QUIZ FUNCTIONALITY
// ===================================

function showQuizBanner() {
    document.getElementById('quizBanner').style.display = 'flex';
}

function hideQuizBanner() {
    document.getElementById('quizBanner').style.display = 'none';
}

function startQuiz() {
    hideQuizBanner();
    state.quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0
    };

    document.getElementById('quizModal').style.display = 'flex';
    renderQuizQuestion();
}

function renderQuizQuestion() {
    const question = QUIZ_QUESTIONS[state.quizState.currentQuestion];

    // Update progress
    document.getElementById('quizProgress').textContent =
        `Question ${state.quizState.currentQuestion + 1} of ${QUIZ_QUESTIONS.length}`;

    // Update question
    document.getElementById('quizQuestionText').textContent = question.question;

    // Render options
    const optionsContainer = document.getElementById('quizOptions');
    optionsContainer.innerHTML = '';

    question.options.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'quiz-option';
        optionDiv.innerHTML = `
            <input type="radio" name="quiz-option" id="option-${index}" value="${index}">
            <label for="option-${index}">${option}</label>
        `;

        optionDiv.addEventListener('click', () => {
            // Select this option
            document.querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            optionDiv.classList.add('selected');
            document.getElementById(`option-${index}`).checked = true;
            document.getElementById('submitAnswer').style.display = 'block';
        });

        optionsContainer.appendChild(optionDiv);
    });

    // Reset feedback and buttons
    document.getElementById('quizFeedback').style.display = 'none';
    document.getElementById('submitAnswer').style.display = 'none';
    document.getElementById('nextQuestion').style.display = 'none';
}

function submitQuizAnswer() {
    const question = QUIZ_QUESTIONS[state.quizState.currentQuestion];
    const selectedOption = document.querySelector('input[name="quiz-option"]:checked');

    if (!selectedOption) return;

    const selectedIndex = parseInt(selectedOption.value);
    const isCorrect = selectedIndex === question.correct;

    // Record answer
    state.quizState.answers.push({
        question: state.quizState.currentQuestion,
        selected: selectedIndex,
        correct: isCorrect
    });

    if (isCorrect) {
        state.quizState.score++;
    }

    // Show feedback
    const feedback = document.getElementById('quizFeedback');
    feedback.className = 'quiz-feedback ' + (isCorrect ? 'correct' : 'incorrect');
    feedback.innerHTML = `
        <h5>${isCorrect ? 'Correct!' : 'Not quite.'}</h5>
        <p>${question.explanation}</p>
    `;
    feedback.style.display = 'block';

    // Mark options
    document.querySelectorAll('.quiz-option').forEach((opt, index) => {
        const input = opt.querySelector('input');
        input.disabled = true;

        if (index === question.correct) {
            opt.classList.add('correct');
        } else if (index === selectedIndex && !isCorrect) {
            opt.classList.add('incorrect');
        }
    });

    // Hide submit, show next
    document.getElementById('submitAnswer').style.display = 'none';
    document.getElementById('nextQuestion').style.display = 'block';
}

function nextQuizQuestion() {
    state.quizState.currentQuestion++;

    if (state.quizState.currentQuestion < QUIZ_QUESTIONS.length) {
        renderQuizQuestion();
    } else {
        showQuizResults();
    }
}

function showQuizResults() {
    closeQuizModal();

    const percentage = Math.round((state.quizState.score / QUIZ_QUESTIONS.length) * 100);
    const score = state.quizState.score;
    const total = QUIZ_QUESTIONS.length;

    document.getElementById('scorePercentage').textContent = `${percentage}%`;

    let message = '';
    if (percentage >= 90) {
        message = "Excellent work. You've mastered this material.";
    } else if (percentage >= 70) {
        message = "Nice work. You've got a solid grasp of most concepts.";
    } else if (percentage >= 50) {
        message = "You're on the right track. Let's review a few areas.";
    } else {
        message = "Let's revisit these concepts to deepen your understanding.";
    }

    document.getElementById('scoreMessage').textContent = message;

    // Show concepts to review
    const reviewList = document.getElementById('reviewList');
    reviewList.innerHTML = '';

    state.quizState.answers.forEach((answer, index) => {
        if (!answer.correct) {
            const question = QUIZ_QUESTIONS[index];
            const li = document.createElement('li');
            li.textContent = question.relatedNode ?
                state.currentDocument.nodes[question.relatedNode]?.title || 'Concept' :
                'Concept';
            reviewList.appendChild(li);
        }
    });

    if (state.quizState.score === total) {
        reviewList.innerHTML = '<li>All concepts mastered! Great job!</li>';
    }

    document.getElementById('resultsModal').style.display = 'flex';
    state.quizTaken = true;
}

function closeQuizModal() {
    document.getElementById('quizModal').style.display = 'none';
}

function closeResultsModal() {
    document.getElementById('resultsModal').style.display = 'none';
}

// ===================================
// GRAPH CONTROLS
// ===================================

let currentScale = 1;

function zoomGraph(factor) {
    currentScale *= factor;
    currentScale = Math.max(0.5, Math.min(2, currentScale));

    const graphCanvas = document.querySelector('.mermaid');
    graphCanvas.style.transform = `scale(${currentScale})`;
    graphCanvas.style.transformOrigin = 'top center';
}

function fitGraphToScreen() {
    currentScale = 1;
    const graphCanvas = document.querySelector('.mermaid');
    graphCanvas.style.transform = 'scale(1)';
}

// ===================================
// ONBOARDING
// ===================================

const onboardingSteps = [
    {
        title: "Welcome to Your Knowledge Graph",
        text: "This graph visualizes key concepts from your document. Each node represents an important idea."
    },
    {
        title: "Click Nodes to Read",
        text: "Click any node to jump to its section in the reading panel. The graph makes navigation intuitive."
    },
    {
        title: "Explore Connections",
        text: "Click the lines between nodes to understand relationships. You'll form your own hypothesis before seeing the explanation."
    },
    {
        title: "Test Your Understanding",
        text: "After exploring, try the quiz to reinforce what you've learned. Active retrieval strengthens memory."
    }
];

let currentOnboardingStep = 0;

function startOnboarding() {
    currentOnboardingStep = 0;
    showOnboardingStep();
}

function showOnboardingStep() {
    if (currentOnboardingStep >= onboardingSteps.length) {
        completeOnboarding();
        return;
    }

    const step = onboardingSteps[currentOnboardingStep];
    document.getElementById('tooltipTitle').textContent = step.title;
    document.getElementById('tooltipText').textContent = step.text;

    const nextBtn = document.getElementById('nextTooltip');
    nextBtn.textContent = currentOnboardingStep === onboardingSteps.length - 1 ? "Get Started" : "Next";

    document.getElementById('onboardingTooltip').style.display = 'flex';
}

function completeOnboarding() {
    state.onboardingComplete = true;
    document.getElementById('onboardingTooltip').style.display = 'none';
    showToast('success', 'All set! Start exploring.');
}

document.getElementById('nextTooltip').addEventListener('click', () => {
    currentOnboardingStep++;
    showOnboardingStep();
});

document.getElementById('skipTour').addEventListener('click', completeOnboarding);

// ===================================
// LOADING OVERLAY
// ===================================

function showLoadingOverlay(title, step) {
    document.getElementById('loadingTitle').textContent = title;
    document.getElementById('loadingStep').textContent = step;
    document.getElementById('progressFill').style.width = '0%';
    document.getElementById('loadingOverlay').style.display = 'flex';
}

function updateLoadingStep(step, progress) {
    document.getElementById('loadingStep').textContent = step;
    document.getElementById('progressFill').style.width = `${progress}%`;
}

function hideLoadingOverlay() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

// ===================================
// TOAST NOTIFICATIONS
// ===================================

function showToast(type, message) {
    const container = document.getElementById('toastContainer');

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icons = {
        success: '✓',
        error: '✗',
        info: 'ℹ'
    };

    toast.innerHTML = `
        <span class="toast-icon">${icons[type] || 'ℹ'}</span>
        <span class="toast-message">${message}</span>
    `;

    container.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
    }, 4000);
}

// ===================================
// UTILITY FUNCTIONS
// ===================================

function closeAllModals() {
    document.getElementById('noteModal').style.display = 'none';
    document.getElementById('connectionModal').style.display = 'none';
    document.getElementById('quizModal').style.display = 'none';
    document.getElementById('resultsModal').style.display = 'none';
}
